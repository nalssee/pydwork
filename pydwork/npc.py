"""Concurrency and parallelism patterns
"""

import math
import random
import string
import inspect
import multiprocessing as mp
import threading as th

from queue import Queue
from itertools import zip_longest


__all__ = ['npc', 'nchunks', 'producers', 'grouper', 'random_string']


def npc(producers, consumer, parallel=False, max_qsize=100):
    """N producers and 1 consumer.

    'producers' is a list of iterators and the number of producers
    is equal to the number of workers (threads or processes spawned)
    'consumer' is a function that takes a value generated by producers
    'consumer' works in the main thread(or process).
    """
    # No idea why but sending object() to a queue causes unexpected result.
    # I suspect pickle fails to properly encode it
    sentinel = random_string() if parallel else object()
    que = mp.Queue(max_qsize) if parallel else Queue(max_qsize)
    worker = mp.Process if parallel else th.Thread
    n_producers = len(producers)

    def insert(producer):
        try:
            for x in producer:
                que.put(x)
        finally:
            que.put(sentinel)

    ws = []
    for producer in producers:
        w = worker(target=insert, args=(producer,))
        w.daemon = True
        ws.append(w)
        w.start()

    sentinel_counter = 0
    while True:
        val = que.get()
        if val == sentinel:
            sentinel_counter += 1
            if sentinel_counter == n_producers:
                break
        else:
            consumer(val)

    for w in ws:
        w.join()


def random_string(nchars=20):
    """Generates a random string of lengh 'n' with alphabets and digits. """
    return ''.join(random.SystemRandom().choice(string.ascii_letters +
                   string.digits) for _ in range(nchars))


def nchunks(xs, n):
    """Yields n chunks about the same size. """
    xs = list(xs)
    chunksize = int(math.ceil(len(xs) / n))
    for i in range(n):
        yield xs[chunksize * i:chunksize * (i + 1)]


# Excerpted from Python referece.
def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)


def producers(fn):
    """Returns a producers generating wrapper.

    *** DO NOT USE THIS AS A DECORATOR IF YOU USE 'fn' SOMEWHERE ELSE
    OR 'fn' ITSELF IS RECURSIVE. SIMPLY WRAP 'fn' AND GIVE IT A NEW NAME.

    'fn' is a generator or a function that accepts one argument.
    """
    def generator_from_generator(chunk):
        for x in chunk:
            for val in fn(x):
                yield val

    def generator_from_fn(chunk):
        for x in chunk:
            yield fn(x)

    def wrapper(xs, n):
        result = []
        gen = generator_from_generator if inspect.isgeneratorfunction(fn)\
            else generator_from_fn
        for chunk in nchunks(xs, n):
            result.append(gen(chunk))
        return result
    return wrapper
